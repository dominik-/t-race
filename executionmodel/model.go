package executionmodel

import (
	"encoding/binary"
	"fmt"
	"strings"

	"github.com/dominik-/t-race/api"
	"github.com/golang/protobuf/ptypes"
)

//Architecture describes a set of sequences (which form a dependency tree), a set of sinks (which are endpoints to which sequences send traces), and a set of environments
//(logical references to deployment environments, which are used by sequences and sinks to learn about collocation)
type Architecture struct {
	Name          string     `yaml:"name"`
	Services      []*Service `yaml:"services,flow"`
	Sinks         []*Sink    `yaml:"sinks,flow"`
	WorkTemplates []*Work    `yaml:"workTemplates,flow"`
	Environments  []string   `yaml:"-"`
}

//Service wraps a set of execution units, as they would be executed by a microservice.
type Service struct {
	//Identifier is an arbitrary, unique identifier of the sequence.
	Identifier string `yaml:"id"`
	//EnvironmentRef is a reference to an environment to manage collocation.
	EnvironmentRef string `yaml:"envRef"`
	//SinkRef is a reference to a sink, i.e. an endpoint, which the worker executing this sequence sends its traces to.
	SinkRef string `yaml:"sinkRef"`
	//Units are wrappers around timed events and calls to other units.
	Units []*Unit `yaml:"units,flow"`
}

//Unit is a wrapper around some work to be done and a call to another sequence.
type Unit struct {
	Identifier string           `yaml:"id"`
	Rel        RelationshipType `yaml:"rel"`
	//Local work to be done before a call to successors is done. String to match defined Work types.
	WorkRef         string     `yaml:"work"`
	WorkTemplate    *Work      `yaml:"-"`
	SuccessorRefs   []*UnitRef `yaml:"successors,flow"`
	InputRefs       []*UnitRef `yaml:"inputs,flow"`
	Context         *Context   `yaml:"context"`
	ThroughputRatio float64    `yaml:"ratio"`
	IsRoot          bool       `yaml:"-"`
	Sync            bool       `yaml:"-"`
}

//UnitRef is a simple wrapper type for mapping request-response vs. fire-and-forget-type interactions.
type UnitRef struct {
	Service string `yaml:"svc"`
	Unit    string `yaml:"unit"`
	Sync    bool   `yaml:"sync"`
}

//Work represents the local work to be emulated by a sequence before the call to a successor is done.
type Work struct {
	Identifier string             `yaml:"id"`
	Type       string             `yaml:"type"`
	Params     map[string]float64 `yaml:"params"`
}

//Context is a wrapper around observable (meta-)data generated by an execution unit.
type Context struct {
	Identifier string              `yaml:"id"`
	Tags       []*KeyValueTemplate `yaml:"tags,flow"`
	Logs       []*KeyValueTemplate `yaml:"logs,flow"`
	Baggage    []*KeyValueTemplate `yaml:"baggage,flow"`
}

//KeyValueTemplate is a container for key-value pairs, which can be described either by their length or a static string. If length is above 0, it is prioritized over static strings.
type KeyValueTemplate struct {
	KeyStatic   string `yaml:"keyStatic"`
	KeyLength   int64  `yaml:"keyLength"`
	ValueStatic string `yaml:"valueStatic"`
	ValueLength int64  `yaml:"valueLength"`
}

//Sink is a wrapper around a backend sequence of a tracing system (something like a proxy/agent, storage/collector, stream pipeline or w/e).
type Sink struct {
	Identifier     string `yaml:"id"`
	Provider       string `yaml:"provider"`
	Address        string `yaml:"address"`
	EnvironmentRef string `yaml:"envRef"`
}

//RelationshipType enum alias.
type RelationshipType int

//This constitutes the relationshipType enum - in golang, an integer with two static representations.
const (
	CHILD RelationshipType = iota
	FOLLOWS
	SERVER
	CLIENT
	PRODUCER
	CONSUMER
	INTERNAL
)

//The stringified values of the enum
var relationshipTypeNames = [...]string{
	"CHILD",
	"FOLLOWS",
	"SERVER",
	"CLIENT",
	"PRODUCER",
	"CONSUMER",
	"INTERNAL",
}

//String returns the static string-values of calltype.
func (r RelationshipType) String() string {
	return relationshipTypeNames[r]
}

func (r *RelationshipType) UnmarshalYAML(unmarshal func(value interface{}) error) error {
	var stringValue string
	err := unmarshal(&stringValue)
	if err != nil {
		return err
	}

	//log.Printf("Parsed string value in YAML: %s\n", stringValue)
	switch stringValue = strings.ToLower(stringValue); stringValue {
	case "child":
		*r = CHILD
	case "follows":
		*r = FOLLOWS
	case "server":
		*r = SERVER
	case "client":
		*r = CLIENT
	case "producer":
		*r = PRODUCER
	case "consumer":
		*r = CONSUMER
	default:
		*r = INTERNAL
	}
	return nil
}

type BenchmarkConfig struct {
	Throughput      int64
	ResultDirPrefix string
	Runtime         int64
}

type Record struct {
	Service     string
	TraceNumber int64
	SpanNumber  int64
	TraceID     string
	SpanID      uint64
	StartTime   int64
	FinishTime  int64
	Sampled     bool
}

type TraceID []byte

func (t TraceID) String() string {
	high := binary.BigEndian.Uint64(t[:8])
	low := binary.BigEndian.Uint64(t[8:])
	if high == 0 {
		return fmt.Sprintf("0x%032x", low)
	}
	return fmt.Sprintf("%x%016x", high, low)
}

func resultsToRecords(results *api.ResultPackage, worker *api.WorkerConfiguration) []*Record {
	resultSlice := results.GetResults()
	records := make([]*Record, len(resultSlice))
	for i := range resultSlice {
		traceID := TraceID{}
		traceID = resultSlice[i].TraceId
		spanID := binary.BigEndian.Uint64(resultSlice[i].SpanId)
		startTime, err := ptypes.Timestamp(resultSlice[i].StartTime)
		endTime, err := ptypes.Timestamp(resultSlice[i].FinishTime)
		if err != nil {
			fmt.Printf("Couldn't convert timestamp %v to time, error was: %s", resultSlice[i].StartTime, err)
		}
		records[i] = &Record{
			Service:     worker.ServiceName,
			TraceNumber: resultSlice[i].TraceNum,
			SpanNumber:  resultSlice[i].SpanNum,
			TraceID:     traceID.String(),
			SpanID:      spanID,
			StartTime:   startTime.UnixNano(),
			FinishTime:  endTime.UnixNano(),
			Sampled:     resultSlice[i].Sampled,
		}
	}
	return records
}
